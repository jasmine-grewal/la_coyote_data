---
title: "look_at_data"
author: "Jasmine Grewal"
format: html
editor: visual
---

```{r}
library(tidyverse)
library(sf)
library(lubridate)
library(parallel)
```

```{r}
#|label: loaddata

read.csv("data/C148.csv") -> C148_data
C148_summary <-  C148_data |>
  add_column(Indv_ID = "C148") |>
  rename(dtUTC = "Date",
         lat = "Latitude",
         lon = "Longitude") |>
  summarise(Indv_ID, lat, lon, dtUTC)

read.csv("data/C172.csv") -> C172_data
C172_summary <- C172_data |>
  add_column(Indv_ID = "C172") |>
  rename(dtUTC = "GPSTime") |>
  summarise(Indv_ID, lat, lon, dtUTC)

read.csv("data/C173.csv") -> C173_data
C173_summary <- C173_data |>
  add_column(Indv_ID = "C173") |>
  rename(dtUTC = "GPSTime") |>
  summarise(Indv_ID, lat, lon, dtUTC)

read.csv("data/C174.csv") -> C174_data
C174_summary <- C174_data |>
  add_column(Indv_ID = "C174") |>
  rename(dtUTC = "GPSTime") |>
  summarise(Indv_ID, lat, lon, dtUTC)

read.csv("data/C175.csv") -> C175_data
C175_summary <- C175_data |>
  add_column(Indv_ID = "C175") |>
  rename(dtUTC = "GPSTime") |>
  summarise(Indv_ID, lat, lon, dtUTC)

read.csv("data/C176.csv") -> C176_data
C176_summary <- C176_data |>
  add_column(Indv_ID = "C176") |>
  rename(dtUTC = "GPSTime") |>
  summarise(Indv_ID, lat, lon, dtUTC)

read.csv("data/C177.csv") -> C177_data
C177_summary <- C177_data |>
  add_column(Indv_ID = "C177") |>
  rename(dtUTC = "GPSTime") |>
  summarise(Indv_ID, lat, lon, dtUTC)

read.csv("data/C178.csv") -> C178_data
C178_summary <- C178_data |>
  add_column(Indv_ID = "C178") |>
  rename(dtUTC = "GPSTime") |>
  summarise(Indv_ID, lat, lon, dtUTC)

read.csv("data/C131_C171.csv") -> C131_C171_data
C131_C171_summary <- C131_C171_data |>
  summarise(Indv_ID, lat, lon, dtUTC)
```

```{r}
coyote_data <- rbind(C131_C171_summary,
                     C148_summary,
                     C172_summary,
                     C173_summary,
                     C174_summary,
                     C175_summary,
                     C176_summary,
                     C177_summary,
                     C178_summary) |>
  rename(LONG = "lon", LAT = "lat",
         ID = "Indv_ID",
         DATE_TIME_LOCAL = "dtUTC") |>
  filter(
```

```{r}
devtools::source_url("https://raw.githubusercontent.com/kyledougherty/CougR/main/a_LoCoH_HR_Function.R")

ACRP1_Home_Range_Estimate <- lapply(data, 
                                    a_LoCoH_HR)

ggplot() + 
  geom_sf(data = ACRP1_Home_Range_Estimate[[1]] %>%
            filter(iso_level == 1), 
          fill = "red") + 
  geom_sf(data = ACRP1_Home_Range_Estimate[[1]] %>%
            filter(iso_level == 0.95), 
          fill = "blue") + 
  geom_sf(data = Sample_Data[[1]])
```

```{r}
data = Sample_Data[[1]]
id = "ID" 
date = "DATE"
min_days = 30
min_fixes = 30
iso_levels = c(0.95, 1)
fill_holes = TRUE
min_neighbors = 2
n_cores = detectCores()- 2
```


```{r}
# Summarise the number of days an individual was tracked and 
# the number of fixes in the dataset
data_summary = data %>%
  st_drop_geometry() %>%
  summarise(Days_Tracked = difftime(max(.[[date]], na.rm = TRUE), 
                                    min(.[[date]], na.rm = TRUE), 
                                    units = "days"),
            n_Fixes = n())
```

```{r}
# min_days = 900

# If the number of days or fixes is less than the user defined 
# threshold (defaults to 30 days/fixes), do not estimate HR and 
# return number of days/fixes with message
if(data_summary$Days_Tracked < min_days | 
   data_summary$n_Fixes < min_fixes){
  
  capture.output(paste("Insufficient data to estimate home range:", 
                       unique(data[[id]]),
                       "n Days =",
                       data_summary$Days_Tracked, 
                       "n Fixes = ", data_summary$n_Fixes, sep = " "))
  
} else{
  
  # Print start time for NN identification to console
  start_time = Sys.time()
  print(paste("Identifying Nearest Neighbors for", 
              nrow(data), "Points:", 
              unique(data[[id]]), Sys.time()))
  }
```
```{r}
# Create a dataframe with the pairwise distance between 
# each point in the telemetry data
pairwise_distances = st_distance(data) %>%
  as_tibble(rownames = "Row_Number", 
            .name_repair = ~paste0("V", str_match_all(.x, "[0-9]+"))) %>%
  mutate(across(everything(), 
                as.numeric))
```

```{r}
# Gets the maximum distance between any two points in 
# the telemetry data. Will serve as the "a" parameter
max_distance = pairwise_distances %>%
  select(-Row_Number) %>% max()
```

```{r}
# Set up parallelization:
# If running on linux/mac, will utilize FORK clusters which are 
# faster to initialize and more memory efficient
if(Sys.info()[["sysname"]] %in% c("Linux", "Darwin")){
  
  cl <- makeCluster(n_cores, type = "FORK")
  
} else{
# If running on windows, will utilize SOCKET clusters,
# which require explicit exporting of any data/packages 
# used in the function being run

  cl <- makeCluster(n_cores)
  clusterExport(cl, c("data", 
                      "pairwise_distances", 
                      "min_neighbors",
                      "max_distance"), 
                envir = environment())
  clusterEvalQ(cl, {
    library(tidyverse)
    library(sf)
  })
}

# The function below will calculate the convex hull for each 
# focal point (each row in the dataframe)
hulls = parLapply(cl,
                  1:nrow(data), 
                  function(row){
                    
                    # From the dataframe with the pairwise distances 
                    # for all points, select the row number and 
                    # column representing the distance to the focal point. 
                    nearest_neighbors = pairwise_distances %>%
                      select(Row_Number, Distance = paste0("V", row)) %>%
                      # Arrange the dataframe by distance
                      arrange(Distance) %>%
                      # Calculate the cumulative distance and filter 
                      # so that only rows where the cumulative distance
                      # is less than "a" (the maximum distance between any 
                      # two points in the dataset) are returned OR 
                      # to meet the specified minimum number of nearest neighbors
                      mutate(Cumulative_Distance = cumsum(Distance)) %>%
                      filter(Cumulative_Distance <= max_distance | 
                               row_number() <= 1 + min_neighbors) %>%
                      # Get the row number representing each point identified 
                      # as a nearest neighbor
                      pull(Row_Number)
                    
                    # Using those points, create the convex hull 
                    # for the focal point and calculate the number
                    # of points contained within the hull and the 
                    # area of the hull
                    hull = data %>% 
                      filter(row_number() %in% nearest_neighbors) %>%
                      st_union() %>%
                      st_convex_hull() %>%
                      st_as_sf() %>%
                      mutate(n_points = length(nearest_neighbors),
                             area = st_area(.))
                    
                  }) %>%
  # Bind hulls into a single dataframe and arrange by the 
  # number of points contained within the hull. If there is 
  # a tie in the number of points contained within hulls, 
  # they are arranged by area, from smallest to largest
  bind_rows() %>%
  arrange(desc(n_points), area)

stopCluster(cl)

print(paste("Hulls Created:", unique(data[[id]]), Sys.time()))

ggplot() + 
  geom_sf(data = hulls)
```
```{r}
ggplot() + 
  geom_sf(data = Sample_Data[[1]]) + 
  geom_sf(data = Sample_Data[[1]][1,], 
          col = "red")
```



```{r}
nearest_neighbors = pairwise_distances %>%
                      select(Row_Number, Distance = paste0("V", 1)) %>%
                      # Arrange the dataframe by distance
                      arrange(Distance) %>%
                      # Calculate the cumulative distance and filter 
                      # so that only rows where the cumulative distance
                      # is less than "a" (the maximum distance between any 
                      # two points in the dataset) are returned OR 
                      # to meet the specified minimum number of nearest neighbors
                      mutate(Cumulative_Distance = cumsum(Distance)) %>%
                      filter(Cumulative_Distance <= max_distance | 
                               row_number() <= 1 + min_neighbors) %>%
                      # Get the row number representing each point identified 
                      # as a nearest neighbor
                      pull(Row_Number)

nearest_neighbors
```
```{r}
# Using those points, create the convex hull 
# for the focal point and calculate the number
# of points contained within the hull and the 
# area of the hull
hull = data %>% 
  filter(row_number() %in% nearest_neighbors) %>%
  st_union() %>%
  st_convex_hull() %>%
  st_as_sf() %>%
  mutate(n_points = length(nearest_neighbors),
         area = st_area(.))

ggplot() + 
  geom_sf(data = hull, 
          fill = NA) + 
  geom_sf(data = Sample_Data[[1]], 
          col = "grey") + 
  geom_sf(data = Sample_Data[[1]] %>%
            filter(row_number() %in% nearest_neighbors), 
          col = "black") + 
  geom_sf(data = Sample_Data[[1]][1,], 
          col = "red")
```
```{r}
ggplot() + 
  geom_sf(data = hulls)
```

```{r}
# This function will repeat until the number of points contained 
# within the union of the hulls is greater than the user defined
# iso_level. For example, if iso_level = 0.95, it will break the loop 
# when a percent of greater than 95% of points contained within the hull 
# is reached, and return the largest union of hulls with < 95% of points 
# contained
Isopleths = lapply(iso_levels, 
                   function(iso_level){
                     
                     # If the iso_level is 1, return the 100% isopleth, 
                     # otherwise get desired isopleth below
                     if(iso_level == 1){
                       
                       Isopleth = hulls %>% 
                         st_union() %>%
                         st_as_sf() %>%
                         mutate(n_contained = lengths(st_intersects(., data)),
                                percent = n_contained/nrow(data), 
                                iso_level = iso_level)
                       
                     }else{
                       
                       # Rather than starting the repeat loop with the hull containing the
                       # the greatest number of points, this creates a sequence ranging from 
                       # 1 to the number of points in the dataset (also the number of hulls). 
                       # Using this sequence, calculate the percent of points contained within 
                       # each hull, then select an initial hull index value (the hull with the 
                       # largest number of points contained that is less than the use defined iso
                       # level).
                       initial_hull_numbers = unique(round(seq(1, nrow(data), length.out = 100)))
                       
                       hull_index = lapply(initial_hull_numbers,
                                           function(hull_index){ 
                                             
                                             hulls %>% 
                                               head(hull_index) %>%
                                               st_union() %>%
                                               st_as_sf() %>%
                                               mutate(n_contained = lengths(st_intersects(., data)),
                                                      percent = n_contained/nrow(data), 
                                                      iso_level = iso_level) 
                                           }) %>%
                         bind_rows(.id = "Index") %>%
                         filter(percent < iso_level) %>%
                         filter(percent == max(percent)) %>%
                         filter(Index == max(Index)) %>%
                         pull(Index)
                       
                       hull_index = initial_hull_numbers[as.numeric(hull_index)]
                       
                       # From the initial hull index identified above, begin the repeat loop
                       
                       repeat{
                         
                         # Create isopleth and test if greater than or
                         # equal to the defined iso_level
                         test_isopleth = hulls %>%
                           head(hull_index) %>%
                           st_union() %>%
                           st_as_sf() %>%
                           mutate(n_contained = lengths(st_intersects(., data)),
                                  percent = n_contained/nrow(data),
                                  iso_level = iso_level)
                         
                         # Break the loop as described above
                         if(test_isopleth$percent >= iso_level){
                           break
                         }
                         
                         # If test_isopleth percent is not greater than iso_level
                         # set as new Isopleth and add 1 to hull_index to restart
                         # the loop
                         hull_index = hull_index + 1
                         
                         Isopleth = test_isopleth
                         
                       }
                       
                     }
                     
                     print(paste(iso_level, "Isopleth Identified:", unique(data[[id]]), Sys.time()))
                     return(Isopleth)
                     
                   })
```


```{r 100% Isopleth}
iso_level = 1

Isopleth = hulls %>% 
  st_union() %>%
  st_as_sf() %>%
  mutate(n_contained = lengths(st_intersects(., data)),
         percent = n_contained/nrow(data), 
         iso_level = iso_level)

ggplot() + 
  geom_sf(data = Isopleth)
```

```{r 95%}
iso_level = 0.95

# Rather than starting the repeat loop with the hull containing the
# the greatest number of points, this creates a sequence ranging from 
# 1 to the number of points in the dataset (also the number of hulls). 
# Using this sequence, calculate the percent of points contained within 
# each hull, then select an initial hull index value (the hull with the 
# largest number of points contained that is less than the use defined iso
# level).
initial_hull_numbers = unique(round(seq(1, nrow(data), length.out = 5)))

hull_index = lapply(initial_hull_numbers,
                    function(hull_index){ 
                      
                      hulls %>% 
                        head(hull_index) %>%
                        st_union() %>%
                        st_as_sf() %>%
                        mutate(n_contained = lengths(st_intersects(., data)),
                               percent = n_contained/nrow(data), 
                               iso_level = iso_level) 
                    }) %>%
  bind_rows(.id = "Index") %>%
  filter(percent < iso_level) %>%
  filter(percent == max(percent)) %>%
  filter(Index == max(Index)) %>%
  pull(Index)

hull_index = initial_hull_numbers[as.numeric(hull_index)]

hull_index
```

```{r}
ggplot() + 
  geom_sf(data = Sample_Data[[1]]) + 
  geom_sf(data = hulls %>%
            head(hull_index) %>%
            st_union())
```


```{r}
# From the initial hull index identified above, begin the repeat loop
repeat{
  
  # Create isopleth and test if greater than or
  # equal to the defined iso_level
  test_isopleth = hulls %>%
    head(hull_index) %>%
    st_union() %>%
    st_as_sf() %>%
    mutate(n_contained = lengths(st_intersects(., data)),
           percent = n_contained/nrow(data),
           iso_level = iso_level)
  
  # Break the loop as described above
  if(test_isopleth$percent >= iso_level){
    break
  }
  
  # If test_isopleth percent is not greater than iso_level
  # set as new Isopleth and add 1 to hull_index to restart
  # the loop
  hull_index = hull_index + 1
  
  Isopleth = test_isopleth
  
}

ggplot() + 
  geom_sf(data = Sample_Data[[1]]) + 
  geom_sf(data = Isopleth)
```

```{r}
Isopleth = Isopleth %>%
  mutate(ID = unique(data[[id]])) %>%
           sfheaders::sf_remove_holes() %>%
           mutate(Area = st_area(.)) %>%
           rename(geometry = x) %>%
           st_transform(4326)

ggplot() + 
  geom_sf(data = Sample_Data[[1]]) + 
  geom_sf(data = Isopleth, 
          fill = NA, 
          col = "red")
```
